class Ring:
    def __init__(self, elements):
        self.elements = elements  # 環的元素
    
    def add(self, a, b):
        # 加法運算，對加法結果取模（此處以環的元素數量作為模）
        return (a + b) % len(self.elements)
    
    def multiply(self, a, b):
        # 乘法運算，對乘法結果取模
        return (a * b) % len(self.elements)

# 示例：定義環 Z_6，即元素為 0, 1, 2, 3, 4, 5
Z_6 = Ring([0, 1, 2, 3, 4, 5])

# 測試加法和乘法
print(f"Addition (4 + 3 mod 6): {Z_6.add(4, 3)}")  # (4 + 3) % 6 = 1
print(f"Multiplication (2 * 3 mod 6): {Z_6.multiply(2, 3)}")  # (2 * 3) % 6 = 0

class Ideal:
    def __init__(self, ring, ideal_elements):
        self.ring = ring  # 環
        self.ideal_elements = ideal_elements  # 理想元素
    
    def is_ideal(self, element):
        return element in self.ideal_elements  # 檢查元素是否在理想中

class QuotientRing:
    def __init__(self, ring, ideal):
        self.ring = ring
        self.ideal = ideal
    
    def add(self, a, b):
        # 商環加法
        return self.ring.add(a, b)
    
    def multiply(self, a, b):
        # 商環乘法
        return self.ring.multiply(a, b)

# 定義理想 I = {0, 3} 在 Z_6 中
ideal_I = Ideal(Z_6, [0, 3])

# 定義商環 Z_6 / I
quotient_ring = QuotientRing(Z_6, ideal_I)

# 測試商環加法和乘法
print(f"Quotient Ring Addition (4 + 3 mod 6): {quotient_ring.add(4, 3)}")
print(f"Quotient Ring Multiplication (2 * 3 mod 6): {quotient_ring.multiply(2, 3)}")

def generate_ideal(a, ring_elements):
    # 生成由元素 a 生成的理想
    return [a * i % len(ring_elements) for i in range(len(ring_elements))]

# 在 Z_6 中，生成由 3 生成的理想
ideal_from_3 = generate_ideal(3, Z_6.elements)
print(f"Ideal generated by 3 in Z_6: {ideal_from_3}")

def factorize(n):
    factors = []
    for i in range(2, n + 1):
        while n % i == 0:
            factors.append(i)
            n //= i
    return factors

# 素因數分解示例
factors_12 = factorize(12)
print(f"Prime factorization of 12: {factors_12}")  # 12 = 2 * 2 * 3
