## 7.3 內容裝載問題

內容裝載問題是指在分散式網絡中，如何將內容分發到多個節點，以達到更高效的內容傳輸和更好的用戶體驗。

通常，內容裝載問題涉及到以下幾個方面：

1. 內容路由：如何有效地找到包含所需內容的節點。

2. 內容下載：如何從節點上下載內容，以最小化延遲和帶寬消耗。

3. 內容更新：如何在內容更新時，快速地將內容分發到所有節點。

為解決這些問題，現有的內容裝載技術包括內容分發網絡（CDN）、點對點網絡（P2P）和分散式哈希表（DHT）等。這些技術通過分發和緩存內容，提高了內容傳輸效率和用戶體驗。


題目描述：

給定n個物品和一個容量為m的倉庫，必須將物品裝入倉庫中。可以選擇不裝載任何物品或者任意幾個物品，但是所有物品都必須被裝載且不能超過倉庫容量。

請設計一個算法，輸出所有方案。

例如，有三個物品，其重量分別為2, 3, 5，容量為6的倉庫，算法输出如下：

(2, 3, 5)
(2, 5, 3)
(3, 2, 5)
(3, 5, 2)
(5, 2, 3)
(5, 3, 2)


算法思路：

使用回溯法，依次判斷每個物品是加入裝載還是不加入裝載，直到所有物品都被判斷完畢。

當判斷完畢一個物品後，如果裝載物品的總重量不超過倉庫容量，就繼續向下遞迴；否則，就回退到上一個決策點，選擇不裝載該物品。直到所有物品都被判斷完畢且裝載物品的總重量恰好等於倉庫容量時，就可以輸出該方案。

程式碼如下：


```
def bin_packing(n, m, items):
    """
    :param n: int, 物品數量
    :param m: int, 倉庫容量
    :param items: List[int], 每個物品的重量
    """
    def backtracking(index, temp):
        # 如果已判斷完最後一個物品，且裝載物品的總重量恰好等於倉庫容量，就輸出該方案
        if index == n and sum(temp) == m:
            print(temp)
            return
        # 如果已判斷完最後一個物品或者裝載物品的總重量超過倉庫容量，就回退到上一個決策點
        if index == n or sum(temp) > m:
            return
        # 選擇加入裝載該物品
        temp.append(items[index])
        backtracking(index + 1, temp)
        temp.pop()
        # 選擇不裝載該物品
        backtracking(index + 1, temp)
    
    backtracking(0, [])
```

測試：

```
>>> bin_packing(3, 6, [2, 3, 5])
[2, 3, 5]
[2, 5, 3]
[3, 2, 5]
[3, 5, 2]
[5, 2, 3]
[5, 3, 2]
```