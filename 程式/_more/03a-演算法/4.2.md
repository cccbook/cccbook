## 4.2 KMP算法

KMP算法（Knuth-Morris-Pratt算法）是一种字符串匹配算法，用于在一个文本串S内查找一个模式串P的出现位置。它的时间复杂度为O(m+n)，其中m为模式串长度，n为文本串长度。

核心思想是利用已经匹配的前缀串信息，来避免在文本串中大量地回溯，从而提高匹配的效率。

具体实现上，首先用P字符串构建一个Next数组，记录P中每个子串的最长前缀子串长度，然后以Next数组为基础，进行匹配操作。如果匹配失败，通过Next数组跳过一部分已经匹配的前缀，重新从该位置继续匹配。

KMP算法的优势在于对于一些较长的文本串和模式串，它的时间复杂度是比较稳定的，而暴力匹配则需要极长的时间才能得到结果。因此，在实际的文本处理中，KMP算法是比较常用的一种模式匹配算法。

下面是用Python实现KMP算法的样例程式：

```python
def kmp(s, p):
    n = len(s)
    m = len(p)
    # 预处理next数组
    next = [0] * m
    j = 0
    for i in range(1, m):
        while j > 0 and p[i] != p[j]:
            j = next[j-1]
        if p[i] == p[j]:
            j += 1
        next[i] = j
    # 匹配过程
    j = 0
    for i in range(n):
        while j > 0 and s[i] != p[j]:
            j = next[j-1]
        if s[i] == p[j]:
            j += 1
        if j == m:
            return i - m + 1
    return -1
```

其中，s和p是要进行匹配的字符串，n和m分别是它们的长度，next数组用于保存p字符串中前缀和后缀公共部分的最大长度，j是一个用于指示p字符串当前匹配的位置的指针，i是一个用于指示s字符串当前匹配的位置的指针。在匹配的过程中，我们不断更新p字符串的匹配位置，如果最后j等于m，那么表明p完全匹配了s的一个子串，返回这个子串的起始位置即可。如果最后都匹配不上，则返回-1。