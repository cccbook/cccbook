## 5.1 背包問題

5.1 背包問題是一個經典的優化問題，其中有一個固定大小的背包和一系列具有不同重量和價值的物品。目標是在不超過背包容量的情況下，選擇一組物品，使其總價值最大化。

這個問題可用動態規劃求解。具體來說，可以定義一個二維數組 dp，其中 dp[i][j] 表示在前i個物品中，容量為j的背包能夠達到的最大價值。然後可以按照以下公式進行更新：

1. 若第i個物品的重量大於當前背包大小j，則 dp[i][j] = dp[i-1][j]，即不選擇第i個物品；
2. 否則，如果選擇第i個物品，那麼 dp[i][j] = dp[i-1][j-w[i]] + v[i]，其中 w[i] 和 v[i] 分別表示第i個物品的重量和價值。這裡的 dp[i-1][j-w[i]] 表示在背包還剩下 j-w[i] 的容量時，前i-1個物品的最大價值；加上 v[i] 則表示可以把第i個物品放入背包中，得到的總價值。

最終，dp[n][V] 即為所求的最大價值，其中 n 表示物品的總數，V 表示背包的容量。


這裡提供一個簡單的 0/1 背包問題的 Python 程式範例：

```python
def knapsack(W, wt, val, n):
    K = [[0 for x in range(W + 1)] for x in range(n + 1)]
     
    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                K[i][w] = 0
            elif wt[i-1] <= w:
                K[i][w] = max(val[i-1] + K[i-1][w-wt[i-1]], K[i-1][w])
            else:
                K[i][w] = K[i-1][w]
 
    return K[n][W]

wt = [10, 20, 30]
val = [60, 100, 120]
W = 50
n = len(val)
print(knapsack(W, wt, val, n))
```

這個程式定義了一個函數 `knapsack`，它接受四個參數：

- `W`: 背包的容量
- `wt`: 每個物品的重量 (一個長度為 n 的串列)
- `val`: 每個物品的價值 (一個長度為 n 的串列)
- `n`: 物品的總數

這個函數返回在背包容量為 W 時，能夠得到的最大價值。

在主函數中，我們定義了一個簡單的輸入，並呼叫 `knapsack` 函數並將結果打印出來。

這個程式的時間複雜度是 O(nW)，空間複雜度也是 O(nW)，其中 n 和 W 都是背包問題的輸入。