### **7.3 位置編碼的數學原理**

位置編碼（Positional Encoding）是 Transformer 等自注意力模型中的一個關鍵技術，用於為序列中的每個元素提供位置信息。由於自注意力機制本身並不具有位置感知的能力，位置編碼的作用是將順序信息嵌入到模型的輸入中，以便讓模型能夠理解元素在序列中的相對位置。位置編碼的實現方式有兩種主要方法：三角函數編碼和學習式位置編碼。

#### **7.3.1 三角函數編碼（Sinusoidal Encoding）**

三角函數編碼是 Transformer 中最常見的固定位置編碼方法。這種方法使用正弦和餘弦函數來對位置進行編碼，能夠有效地捕捉元素之間的相對順序。具體的數學推導如下：

1. **公式推導**：
   
   給定一個序列中的位置  $`i`$  和模型的嵌入維度  $`d_{\text{model}}`$ ，位置編碼  $`PE(i)`$  被定義為以下兩個公式：

   - 對於偶數維度（ $`2k`$ ）：
     
```math
PE_{i, 2k} = \sin\left( \frac{i}{10000^{2k/d_{\text{model}}}} \right)
```


   - 對於奇數維度（ $`2k+1`$ ）：
     
```math
PE_{i, 2k+1} = \cos\left( \frac{i}{10000^{2k/d_{\text{model}}}} \right)
```


   其中：
   -  $`i`$  是序列中位置的索引（從 0 開始）。
   -  $`k`$  是位置編碼向量的維度索引，表示向量中的某一維。
   -  $`d_{\text{model}}`$  是模型的嵌入維度，通常是 Transformer 模型中每個位置的向量維度。

2. **數學解釋**：
   - 位置編碼中的每一個維度都對應於一個特定的頻率，這樣使得位置編碼在不同維度上具有不同的變化速率。低維度的編碼變化較快，而高維度的編碼變化較慢。
   - 這樣設計的好處是能夠捕捉序列中不同位置之間的相對關係。例如，正弦函數可以捕捉到元素之間的相對頻率，而餘弦函數則能夠捕捉到位置之間的相對距離。

3. **優勢**：
   - 固定編碼，無需學習額外參數。
   - 可有效捕捉長序列中的相對位置關係。
   - 無論序列長度如何變化，都能夠提供合理的位置信息。

#### **7.3.2 學習式位置編碼（Learned Positional Encoding）**

另一種位置編碼方法是學習式位置編碼，它不像三角函數編碼那樣固定，而是將位置編碼視為可訓練的參數，並通過反向傳播學習得到最佳的位置信息。具體來說，學習式位置編碼通過將每個位置的編碼向量初始化為可訓練的向量，並在模型訓練過程中調整這些向量，使其能夠有效地捕捉到序列中位置的相對關係。

1. **公式推導**：

   假設模型有一個序列長度為  $`N`$  的輸入，並且嵌入維度為  $`d_{\text{model}}`$ ，則學習式位置編碼是一個大小為  $`N \times d_{\text{model}}`$  的矩陣，記為  $`P_{\text{learned}}`$ ，其中每一行對應於序列中的一個位置編碼。這些位置編碼在訓練過程中作為可學習的參數進行優化。

   - 對於位置  $`i`$  的位置編碼  $`PE(i)`$ ，我們有：
     
```math
PE(i) = \text{Learned}_{i}
```

     其中， $`\text{Learned}_{i}`$  是位置  $`i`$  的學習式位置編碼向量，這些向量會在訓練過程中不斷更新。

2. **數學解釋**：
   - 這種方法的基本思想是將每個位置的編碼視為一個參數，通過訓練來學習這些參數的最佳值。這樣，模型可以在學習過程中根據數據的特性調整位置編碼，使其能夠更好地捕捉到序列中元素的相對關係。
   - 儘管這種方法使得位置編碼的表示更靈活，但它需要額外的學習參數，且在處理極長序列時可能會遇到性能瓶頸。

3. **優勢與劣勢**：
   - 優勢：可以根據訓練數據自動調整位置編碼，能夠學習到更靈活的位置信息，並且能夠在某些特定任務上表現得更好。
   - 劣勢：增加了額外的學習參數，可能會增加模型的計算負擔，並且需要更多的訓練數據來學習有效的編碼。

#### **7.3.3 小結**

位置編碼是 Transformer 等自注意力模型中的核心組件，用於將位置信息引入到序列模型中。三角函數編碼是一種固定的編碼方式，能夠高效捕捉長序列中的相對位置關係，並且不需要額外的學習參數；而學習式位置編碼則是一種可訓練的編碼方法，通過學習參數來適應特定的任務需求。兩者各有優勢，選擇使用哪種方法通常取決於具體的任務和計算資源。